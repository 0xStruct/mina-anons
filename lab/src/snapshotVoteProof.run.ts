import 'dotenv/config';
import {
  snapshotVoteProofProgram,
  Secp256k1,
  Ecdsa,
  Scalar,
  Bytes64,
} from './snapshotVoteProof.js';
import {
  Gadgets,
  Poseidon,
  Keccak,
  Field,
  Bytes,
  Signature,
  PrivateKey,
} from 'o1js';

import { hashMessage, recoverPublicKey } from 'viem';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';

// create accounts with viem
let accounts = [
  privateKeyToAccount(generatePrivateKey()),
  privateKeyToAccount(generatePrivateKey()),
  privateKeyToAccount(generatePrivateKey()),
  privateKeyToAccount(generatePrivateKey()),
  privateKeyToAccount(generatePrivateKey()),
];

console.log('=== sign with viem');
const message = 'hello';
console.log('messageHash', message, hashMessage(message));

const signature0 = await accounts[0].signMessage({ message });
console.log('signature0', signature0);

const publicKeyHex = await recoverPublicKey({
  hash: hashMessage(message),
  signature: signature0,
});

console.log('recovered publicKey', publicKeyHex);

const ethAddressFields = Keccak.ethereum(
  Bytes.fromHex(publicKeyHex.substring(4))
)
  .toFields()
  .slice(12);

type Point = { x: Gadgets.Field3; y: Gadgets.Field3 };

// publicKeyPoint is derived from X and Y point of the publickey which can be recovered from signature
// its format is 0x + X + Y
console.log(
  'publicKey X, Y',
  publicKeyHex.substring(4, 68),
  publicKeyHex.substring(68)
);

let publicKeyPoint: Point = {
  x: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(4, 68))),
  y: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(68))),
};

// publicKey: 0x + X + Y
let bytesOfXY = Bytes64.fromHex(publicKeyHex.substring(4));
console.log('publicKeyHex run', publicKeyHex);

let signature = Ecdsa.fromHex(signature0);
let msgHashScalar = Scalar.from(BigInt(hashMessage(message)));
let publicKeyCurve = Secp256k1.from(publicKeyPoint);
let msgHashHash = Poseidon.hash(msgHashScalar.toFields());

// let slip_id = Field("25029458601869810033071111685846709248060560390983246472539975473834231578977");
const slip_id = Poseidon.hash([
  Poseidon.hash(ethAddressFields),
  Field(process.env.ORACLE_SECRET!),
  // Field(BigInt(hashMessage(space+'/proposal/'+proposal)))
]);

// let oracle_signature = Signature.fromBase58("7mX74P1QUtrMGrbdigNhHAzG4r3q79hnwWXRDoTbehTR9vzfTs2wVawtfraAZkvgjWtGP9qCYBN3zygrHAe4w7pssPgN5GJQ");
const oracle_privateKey = PrivateKey.fromBase58(
  process.env.ORACLE_PRIVATE_KEY!
);
const oracle_signature = Signature.create(oracle_privateKey, [slip_id]);

// investigate the constraint system generated by ECDSA verify
console.time('verify snapshot vote proof (build constraint system)');
let program = await snapshotVoteProofProgram.analyzeMethods();
console.timeEnd('verify snapshot vote proof (build constraint system)');
console.log(program.verify.summary());

// compile and prove
console.time('verify snapshot vote proof (compile)');
await snapshotVoteProofProgram.compile();
console.timeEnd('verify snapshot vote proof (compile)');

console.time('verify snapshot vote proof (prove)');
let proof = await snapshotVoteProofProgram.verify(
  msgHashScalar,
  msgHashHash,
  signature,
  publicKeyCurve,
  bytesOfXY,
  oracle_signature,
  slip_id
);
console.timeEnd('verify snapshot vote proof (prove)');

proof.publicOutput.assertTrue('ownership not valid');

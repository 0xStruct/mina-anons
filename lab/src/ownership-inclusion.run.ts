import {
  verifyOwnershipInclusionProgram,
  Secp256k1,
  Ecdsa,
  Scalar,
  MerkleProof,
  Bytes64,
} from './ownership-inclusion.js';
import { Gadgets, Poseidon, Keccak, Field, Bytes } from 'o1js';
import assert from 'assert';
import fs from 'fs';

import { MerkleTree } from './lib/merkle/merkle_tree.js';
import { Level } from 'level';
import { LevelStore } from './lib/store/level_store.js';

import * as ethjsUtil from '@ethereumjs/util';
import Web3 from 'web3';
const web3 = new Web3(/* PROVIDER */);

// create an account with web3.js
let account = web3.eth.accounts.create();
console.log('account', account);

console.log('=== sign with web3.js');
const message = 'hello';
const web3SignedMessage = web3.eth.accounts.sign(message, account.privateKey);

console.log('hashMessage', web3.eth.accounts.hashMessage(message));
console.log('web3SignedMessage', web3SignedMessage);

let sig3 = web3SignedMessage;
console.log(
  'web3 recover',
  web3.eth.accounts.recover(message, sig3.v, sig3.r, sig3.s)
);

const publicKey = ethjsUtil.ecrecover(
  ethjsUtil.hexToBytes(sig3.messageHash),
  BigInt(sig3.v),
  ethjsUtil.hexToBytes(sig3.r),
  ethjsUtil.hexToBytes(sig3.s)
);

const publicKeyHex = ethjsUtil.bytesToHex(publicKey);
console.log('Recovered public key', publicKeyHex);

// const ethereumAddressFields = Keccak.ethereum(Bytes.fromHex(publicKeyHex.substring(2))).toFields().slice(12);

type Point = { x: Gadgets.Field3; y: Gadgets.Field3 };

// publicKeyPoint is derived from X and Y point of the publickey which can be recovered from signature
// its format is 0x + X + Y
console.log('X', publicKeyHex.substring(2, 66));
console.log('Y', publicKeyHex.substring(66));

let publicKeyPoint: Point = {
  x: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(2, 66))),
  y: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(66, 130))),
};

// publicKey: 0x + X + Y
let bytesOfXY = Bytes64.fromHex(publicKeyHex.substring(2));

let signature = Ecdsa.fromHex(web3SignedMessage.signature);
let msgHash = Scalar.from(BigInt(web3SignedMessage.messageHash));
let publicKeyCurve = Secp256k1.from(publicKeyPoint);

console.log('###');

// [remove for actual use]
// clean the './db' folder as dynamic keypair is used for each run
fs.rmSync('./db', { recursive: true, force: true });

// off-chain persistence with levelDB
const levelDb = new Level<string, any>('./db');

let store: LevelStore<Field> = new LevelStore<Field>(
  levelDb,
  Field,
  'inclusionSet'
);

// hash is derived from publicKey point
let hash0 = Poseidon.hash(Keccak.ethereum(bytesOfXY).toFields().slice(12));
console.log("hash0", hash0);

// hash is derived from eth addresses without 0x prefix
let hash1 = Poseidon.hash(
  Bytes.fromHex('AB3Dc529EF147414288f65ee7E166407B165b483').toFields()
);
let hash2 = Poseidon.hash(
  Bytes.fromHex('05912fD7D55a7f604c6080CAc5F86982eC199136').toFields()
);
let hash3 = Poseidon.hash(
  Bytes.fromHex('4C09CEDa6641d7036F6C6B6525068Dad5e8a2937').toFields()
);

// build or load MerkleTree
let tree: MerkleTree<Field>;

try {
  // load from level store
  console.log('loading from off-chain storage levelDB ...');
  tree = await MerkleTree.import<Field>(store, 8, Field);
  console.log(tree.getRoot().toString());
} catch (e) {
  console.log('leveldb is not there, building tree ...');
  tree = await MerkleTree.build<Field>(store, 8, Field);

  await tree.update(0n, hash0);
  await tree.update(1n, hash1);
  await tree.update(2n, hash2);
  await tree.update(3n, hash3);
}

console.log('tree.getRoot', tree.getRoot().toString());

// now that we got our accounts set up, we need the commitment to deploy our contract!
const merkleRoot = tree.getRoot();

let merkleProof = await tree.prove(0n);
console.log('merkleProof.root', merkleProof.root.value);

let merkleIndex = Field(0n);

// investigate the constraint system generated by ECDSA verify

console.time('ecdsa verify only (build constraint system)');
let program = await verifyOwnershipInclusionProgram.analyzeMethods();
console.timeEnd('ecdsa verify only (build constraint system)');
console.log(program.verifyOwnershipInclusion.summary());

// compile and prove

console.time('verify ownership + inclusion (compile)');
await verifyOwnershipInclusionProgram.compile();
console.timeEnd('verify ownership + inclusion (compile)');

console.time('verify ownership + inclusion (prove)');
let proof = await verifyOwnershipInclusionProgram.verifyOwnershipInclusion(
  msgHash,
  signature,
  publicKeyCurve,
  merkleRoot,
  merkleProof,
  merkleIndex,
  bytesOfXY
);
console.timeEnd('verify ownership + inclusion (prove)');

proof.publicOutput.assertTrue('signature wrong');
assert(await verifyOwnershipInclusionProgram.verify(proof), 'proof wrong');

import { Secp256k1, Ecdsa, verifyEcdsaOwnershipProgram, Scalar } from "./ownership.js";
import { Gadgets, Poseidon, Field } from "o1js";
import assert from "assert";


// create an example ecdsa signature
// BigInteger priv = new BigInteger("1b9cdf53588f99cea61c6482c4549b0316bafde19f76851940d71babaec5e569", 16);
/*
  A public key is just an x and y coordinate, so ultimately it's just two very large 256-bit numbers:
  However, when displaying a public key we typically start by converting these numbers as two 32-byte hexadecimal values:
  
  let publicKey = Point.from({
    x: 49781623198970027997721070672560275063607048368575198229673025608762959476014n,
    y: 44999051047832679156664607491606359183507784636787036192076848057884504239143n,
  });
  */

// let privateKey = Secp256k1.Scalar.random();
// this is a throwaway private key with no assets
let privateKey =
  0xc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9n;
let privateKeyHex = "0x" + privateKey.toString(16); // hex of above

let publicKey = Secp256k1.generator.scale(privateKey);

console.log("privateKey:", privateKey, privateKeyHex);

console.log(
  "publicKey:",
  publicKey.x.toBigInt().toString(16),
  publicKey.y.toBigInt().toString(16)
);
console.log("###");

type Point = { x: Gadgets.Field3; y: Gadgets.Field3 };

// private key: 5822 ... 7457
// publicKeyPoint is derived from X and Y point of the publickey which is derived from privatekey
let publicKeyPoint: Point = {
  x: Gadgets.Field3.from(
    0xdbaabad79c8bb070cab1c0b3dc262eff1f27971513e99f6f22367689805f3f9en
  ),
  y: Gadgets.Field3.from(
    0xcd6f35df4ac3139230e6f2013b2ebaa384122a9bd714df5980d0c2ba39db535cn
  ),
};

let publicKeyCurve = Secp256k1.from(publicKeyPoint);

let signature = Ecdsa.fromHex(
  "0xa6f8e2528055500a724d7201c8d6baf34cf85c704a80c954b708e86d9eae4c685dbf6b15d9f306fb0836f29b561f4c28fcf5e892033b1caf6c83bbf65d394e141b"
);

let msgHash =
  Scalar.from(
    0x50b2c43fd39106bafbba0da34fc430e1f91e3c96ea2acee2bc34119f92b37750n
  );

let publicKeyHash = Poseidon.hashPacked(Secp256k1.provable, publicKey);
console.log("publicKeyHash", publicKeyHash.toString());

// investigate the constraint system generated by ECDSA verify
console.time("ecdsa verify only (build constraint system)");
let csEcdsa = await verifyEcdsaOwnershipProgram.analyzeMethods();
console.timeEnd("ecdsa verify only (build constraint system)");
console.log(csEcdsa.verifySignedHash.summary());

// compile and prove
console.time("verifyEcdsaOwnershipProgram (compile)");
await verifyEcdsaOwnershipProgram.compile();
console.timeEnd("verifyEcdsaOwnershipProgram (compile)");

console.time("verifyEcdsaOwnershipProgram (prove)");
let proof = await verifyEcdsaOwnershipProgram.verifySignedHash(msgHash, signature, publicKeyCurve);
console.timeEnd("verifyEcdsaOwnershipProgram (prove)");

proof.publicOutput.assertTrue("signature wrong");
assert(await verifyEcdsaOwnershipProgram.verify(proof), "proof wrong");

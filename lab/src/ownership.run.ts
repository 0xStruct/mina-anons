import {
  Secp256k1,
  Ecdsa,
  verifyEcdsaOwnershipProgram,
  Scalar,
} from './ownership.js';
import { Gadgets } from 'o1js';
import assert from 'assert';

import { hashMessage, recoverPublicKey } from 'viem';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';

/*
  A public key is just an x and y coordinate, so ultimately it's just two very large 256-bit numbers:
  However, when displaying a public key we typically start by converting these numbers as two 32-byte hexadecimal values:
  
  let publicKey = Point.from({
    x: 49781623198970027997721070672560275063607048368575198229673025608762959476014n,
    y: 44999051047832679156664607491606359183507784636787036192076848057884504239143n,
  });
  */

// create accounts with viem
let accounts = [
  privateKeyToAccount(generatePrivateKey()),
  // privateKeyToAccount(generatePrivateKey()),
  // privateKeyToAccount(generatePrivateKey()),
  // privateKeyToAccount(generatePrivateKey()),
  // privateKeyToAccount(generatePrivateKey()),
];

console.log('=== sign with viem');
const message = 'hello';
console.log('messageHash', message, hashMessage(message));

const signature0 = await accounts[0].signMessage({ message });
console.log('signature0', signature0);

const publicKeyHex = await recoverPublicKey({
  hash: hashMessage(message),
  signature: signature0,
});

console.log('recovered public key', publicKeyHex);

// const ethereumAddressFields = Keccak.ethereum(Bytes.fromHex(publicKeyHex.substring(2))).toFields().slice(12);

type Point = { x: Gadgets.Field3; y: Gadgets.Field3 };

// publicKeyPoint is derived from X and Y point of the publickey which can be recovered from signature
// its format is 0x + X + Y
console.log('X', publicKeyHex.substring(2, 66));
console.log('Y', publicKeyHex.substring(66));

let publicKeyPoint: Point = {
  x: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(2, 66))),
  y: Gadgets.Field3.from(BigInt('0x' + publicKeyHex.substring(66, 130))),
};

let signature = Ecdsa.fromHex(signature0);
let msgHash = Scalar.from(BigInt(hashMessage(message)));
let publicKeyCurve = Secp256k1.from(publicKeyPoint);

// investigate the constraint system generated by ECDSA verify
console.time('ecdsa verify only (build constraint system)');
let csEcdsa = await verifyEcdsaOwnershipProgram.analyzeMethods();
console.timeEnd('ecdsa verify only (build constraint system)');
console.log(csEcdsa.verifySignedHash.summary());

// compile and prove
console.time('verifyEcdsaOwnershipProgram (compile)');
await verifyEcdsaOwnershipProgram.compile();
console.timeEnd('verifyEcdsaOwnershipProgram (compile)');

console.time('verifyEcdsaOwnershipProgram (prove)');
let proof = await verifyEcdsaOwnershipProgram.verifySignedHash(
  msgHash,
  signature,
  publicKeyCurve
);
console.timeEnd('verifyEcdsaOwnershipProgram (prove)');

proof.publicOutput.assertTrue('signature wrong');
assert(await verifyEcdsaOwnershipProgram.verify(proof), 'proof wrong');
